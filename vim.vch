# Voice mappings for vim (enabled applications )
# 051213: tan modified
# vim.vch

include keys.vch;
 
# common ranges
<0to9> := 0..9;
<2to9> := 2..9;
<1to20> := 1..20;
<1to30> := 1..30;

# vim versions of text editing Mappings established in vocola general commands
# ---------------------------------------------------------------------------
# Text Editing
#
<direction>             := Left | Right | Up | Down;
<left_right>            := (Left={b} | Right={w});
<top_bottom>             := (Top={Shift+h} | Bottom={Shift+l} | Middle={Shift+m});

### Characters ( assumes we are in insert mode when calling)
<1to30> <direction>                       =  {$2_$1};
(Change={c} | Copy={y}) (Char | 1 | One)  =  {Esc}{Right}"$1l";
(Change={c} | Copy={y}) Back [1]          =  {Esc}{Right}"$1h";
(Change={c} | Copy={y}) <1to30> [Chars]     =  {Esc}{Right}"$2$1l";
(Change={c} | Copy={y}) Back <1to30> [Chars]     =  {Esc}{Right}"$2$1h";
Kill (Char | 1 | One)                     =  {Del}; # {Right}"$1l";
Kill Back [1]                             =  {Left}{Del};
Kill <1to30> [Chars]                      =  {Del_$1};
Kill Back <1to30> [Chars]                 =  {Left_$1}{Del_$1}; #{Esc}{Right}"$2$1h";
Change case [(back=1)] [<1to30>] = {Esc} When($1, When($2, {Left_$2}, {Left})) When($2, $2~, ~);

### Words
[One] Word                                =  {Esc}"w";
Back [One] Word                           =  {Esc}"b";
<1to30> Words                             =  {Esc}"$1w";
Back <1to30> Words                        =  {Esc}"$1b";
<edit_mode> Word                          =  {Esc}"$1w";
<edit_mode> <1to30> Words                 =  {Esc}"$1$2w";
<edit_mode> Back Word                     =  {Esc}"$1b";
<edit_mode> Back <1to30> Words            =  {Esc}"$1$2b";
<edit_mode> Next Word                     =  {Esc}"w$1w";

### Lines (modify parts of/whole lines)
<line_actions> := (
    Move to=":.m" | Copy to=":.co" | Change="cc" | Kill="dd" | Copy="yy" | 
    Sub=":.s///{Left_2}" | Duplicate="yyp" | Start="\^i" | Append="i{end}" | 
    beginning="20li" | middle="40li" | near the end="60li" | 
    New Here="i{enter}" | New insert="o" | New Back="O" | Append semicolon="\$i;" 
);
<edit_mode>             := (Change={c} | Kill={d} | Copy={y}); # Indent= | Comment=

# current line action (no line number specified)
<line_actions> Line                                             =  {Esc}$1;
Swap [(Back=Up | Next=Space)] [Line]                              =  {esc} When($1, {$1}, "") "ddp";
<edit_mode> (Beginning="0" | Start="^" | End="\$") [Line] [Here]  =  {Esc}$1 When($2, $2,  "\$");
Blank (back=O{down} | insert=o{up}) [Line]                         =  {esc}$1{esc};
Join [(Back=Up | Next=Space)] [Line]                             =  {esc} When($1, {$1}) "J";

# multiple line action (relative range specified)
<relative_range_actions> := (
    Change="c{enter}" | Kill="d{enter}" | Copy="y{enter}" | 
    Move to="m" | Copy to="co" | copy here="co-1{enter}" |
    Duplicate="yyp{enter}" | indent=">{enter}" | reverse indent="<{enter}" |
    Sub="s///gc{Left_4}" | Comment="TComment{enter}" |
    Start="{enter}i" | Append="{enter}i{end}" 
);
<relative_range_actions> (Next="+" | Back="-") Line                          =  {Esc}":"$2"1$1";
<relative_range_actions> 2..30 Lines                                   =  {Esc} ":.,+" Eval($2-1) "$1";
<relative_range_actions> Back 2..30 Lines                                   =  {Esc} ":-$2,-1$1"; 

# multiple line action with range specified
<range_actions> := (
    Move to="m" | Copy to="co" | Change="c" | Kill="d" | Copy="y" | 
    Sub="s///" | copy here="co." | comment="TComment"
);
<range_actions> Range = {esc}":$1"{Home};

### Entire "Flow"
<insert> := (insert=I | append=A);
Flow (Start="gg" | Append="G") [<insert>]                      =  {Esc}"$1" Wait(20) "$2";
<edit_mode> (Flow Here=".,\$" | Flow All="0,\$" | Back Flow Here="0,.")   =  {Esc}":$2$1"{Enter};

# other rule specifications for text editing
(Indent=">" | reverse indent="<") (Line={enter} | Range={Left}) [1..9] = When($3, Repeat($3, {Esc}":$1"$2), {esc}":$1"$2);

<sub_action> := (line="s" | all="%s" | here=".,\$s" | back here="0,.s");
(sub | substitute) <sub_action>       =  {Esc}":$2///gc"Repeat(4, {Left});

<text_actions> := (
    Paste=p | Paste Back=P | Insert=i | Append=a | Substitute=s | Replace=R | 
    diff push=dp | diff pull=do | diff next="\]c" | diff back="\[c" 
);
<text_actions> = {esc}$1;

# standard actions
<standard_actions> := (
    Start macro=qz | Repeat macro=@z{Enter} | Format=Q | Normal mode= | 
    visual mode={ctrl+v} 
);
<standard_actions> = {esc}$1;
edit (undo=u | redo={ctrl+r}) [<2to9>] = {esc} When($2, $2$1, 1$1);

#*-------------------------------------------- */ 
#  navigation specific commands

###
### Jump to start of absolute line number L (directly up to 99,999):
# stop 1 being recognised as "one" in Vocola
$set numbers 0;
## go to absolute line number $line:
## vim mark line "v" incase we want to return to the original line
GotoLineMod(line, mod) := {Esc}"mv" ":$line"{enter} Wait(500) "$mod"; 
GotoLine4Mod(thousands, hundreds, tens, ones, mod) :=
    GotoLineMod(Eval($thousands*1000 + $hundreds*100 + $tens*10 + $ones), $mod);
<line_mod> := (
    Start="zzI" | Append="zzA" | Sub=":s///{Left_2}" |
    Scroll [to] bottom="zb" | Scroll [to] top="zt" | Scroll [to] middle="zz" |
    beginning="20li" | middlie="40li" | end="60li" |
    New back="zzO" | insert="zzo" | 
    # For the following commands we want to perform actions in place, 
    # IE. returns to original line (mark "v").
    Change=":.c{enter}" "'v" | Kill=":.d{enter}" "'v" |
    Copy=":.y{enter}" "'v" | Paste="p" "'v" | Paste Back="P" "'v" | 
    Move to=":.m" | Copy to=":.co" | copy here=":.y{enter}" "'v" "p" | 
    indent=":>{enter}" "'v"| reverse indent=":<{enter}" "'v"| 
    Comment=":TComment{enter}" "'v" |
    Blank back="O{esc}" "'v" | Blank insert="o{esc}" "'v"
);
line [<line_mod>] <0to9>                      = GotoLineMod($2,$1);
line [<line_mod>] <0to9> <0to9>               = GotoLine4Mod(0, 0, $2, $3, $1);
line [<line_mod>] <0to9> <0to9> <0to9>        = GotoLine4Mod(0, $2, $3, $4, $1);
line [<line_mod>] <0to9> <0to9> <0to9> <0to9> = GotoLine4Mod($2, $3, $4, $5, $1);



# special navigation actions
<navigation_actions> := (
    List changes=":changes" | back change="g;" | Undo jump="``" | 
    Return from="''" | Set mark="mz" | Goto mark="'zi" |
    Append back="-i{end}{{Left}{Del}" | Append next="+i{end}{{Left}{Del}" |
    Start back="-i" | Start next="+i" | Match bracket="%" |
    Scroll [to] bottom="zb" | Scroll [to] top="zt" | Scroll [to] middle="zz"
);
<navigation_actions> = {esc}$1;
Halfpage [(Up="u" | Down="d")]  = {Esc} When($1, {Ctrl+$1}, {Ctrl+d});
Page <top_bottom>               = {Esc}$1;
##next change="g," 

Back till <key>                            =  {Esc}"T$1";
Till <key>                                 =  {Esc}"t$1";
Till next                                =  {Esc}";";
Search <_anything>                         =  {Esc}"/\c$1";
Search go <_anything>                      =  {Esc}"/\c$1"{enter};
clear Search                               =  {Esc}"/zzz"{enter};

# commandline actions
Make                                       =  {Esc}":make";
Vim Update Tag File                        =  {Esc}":!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q ."{Enter};
List errors                                =  {Esc}":clist";
Next error                                 =  {Esc}":cn";
back error                             =  {Esc}":cp";
Save file                                  =  {Esc}":w"{Enter};
Close file                                 =  {Esc}":q"{Enter};
Save and close file                        =  {Esc}":x"{Enter};
#confirm force close definite              =  {Esc}":q!";
back command [1..9]                  =  When($1, Repeat($1, {Esc}":"{up}{enter}), {Esc}":"{up});
Edit another                               =  {Esc}":e ";
File browser                               =  {Esc}":e."{Enter};
vim diff split  = {esc}":vert diffsplit ";

# text shortcuts
#Def include                                =  {Esc}"i#include ";
#Def Define                                 =  {Esc}"i#define ";
#Def ifdef                                  =  {Esc}"\pid"{enter};
#file Printf                                  =  {Esc}"i"{Right}"fprintf(,);" {Left_3};
#Equals                                    =  {Esc}i{right}= ";
#Hash                                      =  {Esc}"i#"{esc};
Insert space                               =  {Esc}"i"{space}{esc};
#insert comment [(escape={Esc} | insert="i" | todo="iTODO: ")]  =  {Esc}":TComment "{enter}$1;
Insert space after                         =  {Esc}"i"{Right}{space}{esc};
#Begin comment                              =  {Esc}"i/* ";
Append comment                                =  {Esc}"i */"{enter};
#Begin long comment                         =  {Esc}"i#"{esc}"ib"{space};
#End long comment                           =  {Esc}"i#"{esc}"ie"{enter};
Insert line break                          =  {Esc}"i"{enter};
insert comment                               =  {Esc}"i#"{esc}"il"{enter};
Double slash backslash                     =  {Esc}"\/\/";
reference                                  =  "-" Wait(500) ">";
Function definition                        =  {Esc}{Right}"idef ():" {Left_3};
Function definition <_anything>            =  {Esc}{Right}"idef $1():" {Left_2};
Show Help                                  =  {Esc}":help ";
Set setting                                =  {Esc}":set ";
Set dark background =  {Esc}":set bg=dark"{enter};
Set light background =  {Esc}":set bg=light"{enter};
reload vim config = {esc}":source ~/.vimrc"{enter};

# window navigation
## move created split one page up, return to top of original page in the right split
Split vertical                   =  {Esc}":vsp"{Enter}{Shift+h}{PgUp}
                                    {Ctrl+w}"l";
<window_action> := (left=h | right=l | up=k | down=j | next=w | close=c );
Vim Window <window_action> = {esc}{ctrl+w}"$1";
Vim Window crop            = {Esc}":only"{Enter};
Vim Window make fat        = {esc}":vertical resize +15"{enter};
Vim Window make thin       = {esc}":vertical resize -15"{enter};

# buffer navigation
back buffer                  =  {Esc}":bp"{Enter};
Close buffer                     =  {Esc}":bd"{Enter};
Next buffer                      =  {Esc}":bn"{Enter};
Switch buffer                    =  {Esc}":b#"{Enter};
Show buffers                     =  {Esc}":buffers"{enter};
numbered buffer <1to30>          =  {Esc}":b$1"{enter};

# tab navigation
<tab_actions> := (back=p | Close=c | Next=n | List=s | Last=l | First=fir);
<tab_actions> tab                 = {Esc}":tab$1"{Enter};
switch tab <1to30>                   = {Esc}":tabn $1"{enter};

# tab navigation
#<tag_actions> := (back=":tN{enter}" | Jump="{Ctrl+]}" | Next=":tn{enter}" | 
#                  Match=":ts{enter}" | Return="{Ctrl+t}" | Stack=":tags{enter}");
vim Tag back={esc}":tN{enter}";
vim Tag Jump={esc}"{Ctrl+]}";
vim Tag Next={esc}":tn{enter}";
Vim Tag Match={esc}":ts{enter}";
Vim Tag Return={esc}"{Ctrl+t}";
Vim Tag Stack={esc}":tags{enter}";
#Vim Tag <tab_actions>               =  {Esc}$1;

# plug-in actions
Vim Folds                            =  {Esc}{ctrl+f};
Vim show Taglist                     =  {Esc}""{ctrl+g};
Vim Align                            =  {Esc}":Align ";
Vim Align <key>                      =  {Esc}":Align $1"{Left_7};
## omnicomplete
complete                             =  {ctrl+x}{ctrl+o};
local complete                       =  {ctrl+p};
Remove preview = {esc}{ctrl+w}{Up}":q{enter}";
# UNITE plug-in, mappings in .vimrc
#Vim Unite                           =  {Esc}":Unite file_rec buffer"{enter};
Unite files                          =  {Esc}"\f";
Unite files recursive                =  {Esc}"\t";
Unite recent                         =  {Esc}"\m";
#Unite outline                       =  {Esc}"\o";
Unite history = {Esc}"\y";
Unite buffer = {Esc}"\e";
Unite insert = {tab} {Down_3} {enter};

# TComment, note: could also be done with csupport
comment (range=Repeat(9, {Left}) | line={enter}) = {esc}":TComment" $1;       
# csupport (hotkey sections: comment, statements, preprocessor, idioms, 
#           snippets, c++, run)
<comment_type> := (
    frame=fr | function=fu | method=me | class=cl | 
    implementation=fdi | header=fdh | source section=cs |
    header section=hs | keyword=kc | special=sc | date=d |
    time=t | toggle type=x
);
<comment_type> comment = \c$1;

<statement_type> := (
    do=d | for=fo | if=if | if else=ife | else=e | while=wh | 
    switch=s | case=c
); 
<statement_type> statement = \s$1;

<idiom_type> := (
    function=f | static=sf | main=m | for increment=0 | print=p | 
    file print=fp
); 
<idiom_type> idiom = \i$1;

start (brace="{{enter}" | comment="/*") [(block={enter})] = {esc}{i}"$1$2";

<preprocessor_type> := (
    include header=ih | include global=< | include local='"' | define=d 
); 
<preprocessor_type> preprocessor = \p$1;

# NeoBundle
Bundle command (Install | Clean | List)            =  {esc}":NeoBundle$1"{enter};
# editor settings
Nowrap                          = "{Esc}:set nowrap{enter}";
setting based                        = "{Esc}:set paste{enter}";
Edit vim RC                     = {Esc} ":e ~\.vimrc" {Enter};
Reload                          = {Esc} ":source \$MYVIMRC" {Enter};

# histories
command history = {Esc}"q:";
pattern match history = {Esc}"q/";
#
##### surplus for reference     -credit neon?
#### Can be used instead of unimacro "brackets" if ^X characters become a problem
###<surround> := ( par = "()" | bar = "||" | quote = "" );
##Surround <surround> = $1{Left};

## temporary project specific macros
histogram debug = {esc}'i#ifdef DEBUG{enter}fsp_log_debug(shared_data_p->config_p->prog_name_p, {enter}"%s: \n", __FUNCTION__);{enter}#endif' {Up}{End} Repeat(19,{Left});
ifdef (debug="DEBUG" | trace="TRACE")                                 =  {Esc}"ddi#ifdef $1"{enter};
ifdef end                                                       = {esc}"o#endif"{enter};
